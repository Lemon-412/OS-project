*Comment：只恨自己对操作系统了解不够深入，很多地方还在瞎写。*

<img src="/README/exp1-2.png" />
<img src="/README/exp8.png" />

## 要求
- 调度算法（个人）
- 死锁避免（个人）
- 分页管理（小组）
- 文件目录（小组）
- \*内存分配
- Shell （个人）

## exp1-2

使用C++模拟一个进程的调度和执行

#### 目前实现的功能
- Process、Job与Process Controller Block的实现
- CPU：基于PCB\*链表的进程控制
- CPU：时钟控制，空闲时busy waiting
- 中断：支持进程主动中断，进行上下文切换。支持调度中断。
- 调度算法：FCFS（非抢占）、修改的SJF（抢占）、RR（按时间片）
- 死锁检测：不检测死锁、预防死锁（按优先级释放资源）

#### 自定目标
- 不使用复杂的数据结构，尽可能只是用链表、数组、队列、栈等基本数据结构，最多使用std::vector
- 不使用不可实现的算法（对比用除外），如各类预知未来的算法（银行家，SJF等）
- 尽可能真实的模拟操作系统的一些方面，从最实际的角度思考问题

#### 代码实现的简要说明
- 设计Event.h事件类。包含事件名称，事件起始时间（即进程运行到第几个时间片触发），需求得不到相应的中断时间长度。如果事件为请求系统资源，需要包含请求资源量。
- 设计JOB.h作业类。包含作业名，创建时间，作业完成需要的时长，作业运行中产生的事件(Event)，优先级（如果是优先级相关的调度算法需要暂存优先级）
- 设计Process.h进程类。包含进程名，创建时间，进程完成需要的时长，进程运行中产生的事件(Event)，进程已经运行的时间，进程阻塞的时长，进程已经获得的资源。其中进程完成需要的时长对CPU透明（不预知未来）。
- 设计PCBControl.h进程队列类。包含一个PCB\*的链表。封装了在进程队列中插入进程和释放进程的方法。
- 设计scheduling.h作业调度算法。根据现有进程PCB\*和就绪进程选取下一个进程。
	- FCFS（非抢占）：如果现有进程非空，则继续选择现有进程，否则选取最早创建的进程
	- 修改的SJF（抢占）：选取运行时间最少的进程
	- RR：如果现有进程非空，则轮转调度选取下一个进程，否则选取第一个进程（如果有）
- 设计DeadLock.h死锁避免算法。根据系统资源向量（总量和当前），决策是否允许分配、返回进程的资源释放向量
	- 无保护：进程永远不释放已有资源；永远允许资源分配
	- 预防死锁（按优先级释放资源）：为资源设计优先级，如果进程在拥有高优先级资源的时候申请低优先级资源，则它需要先释放所有更高优先级的资源。
- 设计CPU.h中央处理器类。包含CPU的基本信息（资源向量、调度算法逻辑、死锁避免逻辑、作业队列、进程就绪队列、进程阻塞队列、进程完成队列、一个存放当前运行进程地址的寄存器）。在每个时钟信号中：
	- 检查是否有新的作业进入，如果有则为其创建进程和PCB，并插入就绪队列
	- 根据作业调度算法提供的接口，获取下一个运行的进程，如果没有这样的进程（即就绪队列为空），则忙等，否则，运行该进程一个时间片，期间：
		- 如果该进程提出了资源分配请求，则根据死锁检测算法提供的接口判断是否分配资源
			- 如果许可分配资源，则先根据死锁检测算法提供的接口释放资源（如果有必要），再分配资源并修改相应资源分配信息
			- 如果驳回，则将进程放入阻塞队列
		- 如果进程提出其他主动中断，则将进程放入阻塞队列
		- 如果该时间片正常完成（没有请求或申请资源受到许可），则将其运行时间加一。若进程运行完成，释放相应资源，将其放入完成队列；否则放入就绪队列
	- 检查阻塞队列，将完成阻塞的进程重新放回就绪队列
	- 运行下一个时间片

## exp8

使用C++在windows下实现Linux的shell的一些基本指令

#### 目前实现的功能
- 简单的语法分析
	- 自左向右按空格分割
	- 但对双引号进行匹配（如 `echo "hello world"` 不会分割成三部分）
	- 捕获非法指令
	- 捕获缺少参数的指令
	- 捕获不合法的路径名
	- 捕获双引号不对齐的指令
	- 不支持括号语法
- 简单的界面
	- 展示当前用户和计算机名
	- 简单的语法高亮
		- 用户和计算机名高亮
		- 当前路径高亮
		- 指令高亮
		- 输出结果高亮
		- 错误高亮
- 实现shell一部分经典指令（但都不允许额外参数"-?"）
	- `echo`: 复读机
	- `clear`: 清屏
	- `ls`: 目录下文件
	- `cd`: 修改目录 特性：使用 `\` 而非 `/` ，不区分大小写，支持比原生shell更宽松的语法
		- shell对路径本身就比较宽松，比如 `cd .` 或 `cd ./` 或 `cd ..` 或 `cd ../` 或 `cd ../././.` 等
		- 特性： 支持 `cd .\..\..\.` 或 `cd .......` 等形式，虽然后者站在语法多义性的考量上应该被禁止
	- `cat`: 文件复读机
	- `mkdir`: 创建新文件夹
	- `rmdir`: 删除空文件夹
	- `touch`: 创建新文件
	- `rm`: 删除文件
	- `>`: 输出重定向
	- `>>`: 输出重定向，追加模式
	- `PATH\NAME.exe`: 执行PATH路径下的可执行程序NAME.exe
	- `exit`: 退出

#### 自定目标
- 没时间了随便写写吧
- 没重大bug就行，有特性就不修了

#### 代码实现的简要说明

代码写得很烂，自己都不想看第二遍

- 设计shell.h类，实现了主体循环，异常捕获
- 设计command.h类，进行语法分析，异常捕获和抛出
- 设计cmds.h类，具体实现每一个指令，异常抛出
